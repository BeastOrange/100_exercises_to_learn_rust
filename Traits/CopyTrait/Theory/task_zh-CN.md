## 复制值，第二部分

让我们考虑与之前相同的例子，但稍作修改：使用 `u32` 而不是 `String` 作为类型。

```rust
fn consumer(s: u32) { /* */ }

fn example() {
     let s: u32 = 5;
     consumer(s);
     let t = s + 1;
}
```

它会编译通过，没有错误！这是为什么呢？`String` 和 `u32` 之间的区别是什么，使得后者不需要使用 `.clone()` 也能正常工作？

## `Copy`

`Copy` 是 Rust 标准库中定义的另一个特性：

```rust
pub trait Copy: Clone { }
```

它是一个标志特性，就像 `Sized` 一样。

如果某个类型实现了 `Copy`，就不需要调用 `.clone()` 来创建该类型的新实例：Rust 会**自动**为你处理。  
`u32` 是一个实现了 `Copy` 的类型，因此上面的例子可以无错误地编译：当调用 `consumer(s)` 时，Rust 会通过**按位复制**创建一个新的 `u32` 实例，然后将这个新实例传递给 `consumer`。这些操作都在幕后完成，你不需要做任何额外的事情。

## 什么类型可以是 `Copy`？

`Copy` 并不等同于“自动克隆”，尽管它隐含这一点。  
要实现 `Copy`，类型必须满足一些要求。

首先，它必须实现 `Clone`，因为 `Copy` 是 `Clone` 的子特性。  
这很合理：如果 Rust 可以**隐式**创建某种类型的新实例，它也应该可以通过调用 `.clone()` **显式**地创建一个新实例。

不过，这还不够。还有一些额外的条件需要满足：

1. 该类型不能管理任何_额外_的资源（例如堆内存、文件句柄等），超过其在内存中所占用的 `std::mem::size_of` 字节。
2. 该类型不能是可变引用（`&mut T`）。

如果以上条件都满足，那么 Rust 可以通过**按位复制**一个原始实例来安全地创建该类型的新实例——这通常被称为 `memcpy` 操作，来源于 C 标准库中执行按位复制的函数。

### 案例研究 1：`String`

`String` 是一个没有实现 `Copy` 的类型。  
为什么？因为它管理一个额外的资源：用于存储字符串数据的堆分配内存缓冲区。

让我们设想一下，如果 Rust 允许 `String` 实现 `Copy` 会发生什么。  
当通过按位复制原实例创建一个新的 `String` 实例时，原实例和新实例都会指向同一个内存缓冲区：

```text
              s                                 copied_s
+---------+--------+----------+      +---------+--------+----------+
| pointer | length | capacity |      | pointer | length | capacity |
|  |      |   5    |    5     |      |  |      |   5    |    5     |
+--|------+--------+----------+      +--|------+--------+----------+
   |                                    |
   |                                    |
   v                                    |
 +---+---+---+---+---+                  |
 | H | e | l | l | o |                  |
 +---+---+---+---+---+                  |
   ^                                    |
   |                                    |
   +------------------------------------+
```

这很糟糕！  
两个 `String` 实例都会试图在超出作用域时释放该内存缓冲区，从而导致双重释放错误。  
你还可能创建两个指向同一内存缓冲区的不同 `&mut String` 引用，从而违反 Rust 的借用规则。

### 案例研究 2：`u32`

`u32` 实现了 `Copy`。实际上，所有整数类型都实现了 `Copy`。  
一个整数“仅仅”是内存中表示该数字的字节。没有更多额外的内容！  
如果你复制这些字节，就会得到另一个完全有效的整数实例。  
不会发生任何问题，因此 Rust 允许它。

### 案例研究 3：`&mut u32`

当我们介绍所有权和可变借用时，明确提出了一条规则：在任何给定时间，只能有_一个_值的可变借用。  
这也是为什么 `&mut u32` 没有实现 `Copy`，即使 `u32` 实现了。

如果 `&mut u32` 实现了 `Copy`，你可以创建多个指向同一值的可变引用，并在多个地方同时修改它。  
这将违反 Rust 的借用规则！  
因此，无论 `T` 是什么，`&mut T` 都永远不会实现 `Copy`。

## 实现 `Copy`

大多数情况下，你不需要手动实现 `Copy`。  
你可以直接派生它，例如：

```rust
#[derive(Copy, Clone)]
struct MyStruct {
    field: u32,
}