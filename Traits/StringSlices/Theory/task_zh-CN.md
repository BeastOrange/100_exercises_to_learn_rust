## 字符串切片

在前面的章节中，你已经在代码中见过许多 **字符串字面量**，例如 `"To-Do"` 或 `"A ticket description"`。  
它们通常会跟着 `.to_string()` 或 `.into()` 的调用。是时候来理解其中的原因了！

## 字符串字面量

通过将原始文本用双引号括起来，你可以定义一个字符串字面量：

```rust
let s = "Hello, world!";
```

`s` 的类型是 `&str`，即**字符串切片的引用**。

## 内存布局

`&str` 和 `String` 是不同的类型，它们不能互换使用。  
让我们回顾一下我们在[之前的探索](../../../Ticket%20v1/Heap/Theory/task.md)中提到的 `String` 的内存布局。  
如果我们运行以下代码：

```rust
let mut s = String::with_capacity(5);
s.push_str("Hello");
```

在内存中的情况是这样的：

```text
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   5    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | l | l | o |
       +---+---+---+---+---+
```

回忆一下，我们已经[研究过](../../../Ticket%20v1/References%20in%20memory/Theory/task.md) `&String` 在内存中的布局：

```text
     --------------------------------------
     |                                    |         
+----v----+--------+----------+      +----|----+
| pointer | length | capacity |      | pointer |
|    |    |   5    |    5     |      |         |
+----|----+--------+----------+      +---------+
     |        s                          &s 
     |       
     v       
   +---+---+---+---+---+
   | H | e | l | l | o |
   +---+---+---+---+---+
```

`&String` 指向存储 `String` 元数据的内存位置。  
如果我们沿着指针查找，就会找到堆分配的数据，特别是字符串的第一个字节 `H`。

那么，如果我们需要一种能表示 `s` 的**子字符串**的类型，比如 `Hello` 中的 `ello`，该怎么办呢？

## 字符串切片

一个 `&str` 是一个字符串的**视图**，它是对存储在其他地方的一段 UTF-8 字节序列的**引用**。  
例如，你可以通过以下方式从一个 `String` 创建一个 `&str`：

```rust
let mut s = String::with_capacity(5);
s.push_str("Hello");
// 从 `String` 创建一个字符串切片引用，
// 跳过第一个字节。
let slice: &str = &s[1..];
```

在内存中的表示如下：

```text
                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
```

`slice` 在栈中存储了以下两部分信息：

- 一个指向切片第一个字节的指针。
- 切片的长度。

`slice` 并不拥有数据，它只是指向它：它是对 `String` 堆分配数据的**引用**。  
当 `slice` 被销毁时，堆分配的数据不会被释放，因为它仍然被 `s` 所拥有。  
这就是为什么 `slice` 没有 `capacity` 字段：它并不拥有数据，不需要知道为其分配了多少空间；它只关心自己引用的数据。

## `&str` 和 `&String`

通常的经验法则是，如果需要引用文本数据，尽量使用 `&str` 而不是 `&String`。  
`&str` 更灵活，也更符合 Rust 的惯用代码风格。

若一个方法返回 `&String`，意味着你在保证某处存在一个堆分配的 UTF-8 文本，并且这个文本和你返回引用的内容完全一致。  
而如果一个方法返回 `&str`，则表示你拥有更多的自由：只是声明某处存在一段文本数据，其中的一部分与你需要的内容匹配，因此你返回对它的一个引用。