## `Sized`

在探讨了 deref 强制转换后，`&str` 所涉及的内容远比看上去多。\
从我们之前关于[内存布局的讨论](../../../Ticket%20v1/References%20in%20memory/Theory/task.md)中，可以合理推测 `&str` 在栈上是表示为单个 `usize`，即一个指针。但事实并非如此。`&str` 在指针旁边还存储了一些**元数据**：它所指向的切片的长度。回到[前面章节](../../String%20slices/Theory/task.md)中的例子：

```rust
let mut s = String::with_capacity(5);
s.push_str("Hello");
// 从 `String` 中创建一个字符串切片引用，
// 跳过第一个字节。
let slice: &str = &s[1..];
```

在内存中，我们得到如下布局：

```text
                    s                              slice
      +---------+--------+----------+      +---------+--------+
Stack | pointer | length | capacity |      | pointer | length |
      |    |    |   5    |    5     |      |    |    |   4    |
      +----|----+--------+----------+      +----|----+--------+
           |        s                           |  
           |                                    |
           v                                    | 
         +---+---+---+---+---+                  |
Heap:    | H | e | l | l | o |                  |
         +---+---+---+---+---+                  |
               ^                                |
               |                                |
               +--------------------------------+
```

这是怎么回事呢？

## 动态大小类型

`str` 是一种**动态大小类型** (DST)。\
DST 是一种在编译时大小未知的类型。当你持有一个指向 DST 的引用时，例如 `&str`，它必须包含额外的信息来描述它指向的数据。这被称为**胖指针**。\
对于 `&str`，它存储了它所指向切片的长度。我们将在后续课程中看到更多 DST 的例子。

## `Sized` 特征

Rust 的 `std` 库定义了一个名为 `Sized` 的特征。

```rust
pub trait Sized {
    // 这是一个空特征，不需要实现任何方法。
}
```

当一个类型的大小在编译时是已知的，它就是 `Sized` 类型。换句话说，它不是 DST。

### 标记特征

`Sized` 是你遇到的第一个**标记特征**。\
标记特征是一种不要求实现任何方法的特征。它不定义任何行为，\
仅用于**标记**某种类型具有特定属性。\
这些标记随后会被编译器利用，以启用某些行为或优化。

### 自动特征

特别是，`Sized` 也是一种**自动特征**。\
你无需显式实现它；编译器会根据类型的定义自动为你实现。

### 示例

到目前为止我们见过的所有类型都是 `Sized` 类型：`u32`、`String`、`bool` 等。

而如我们刚刚所见，`str` 不是 `Sized`。\
但 `&str` 是 `Sized`！因为我们在编译时知道它的大小：两个 `usize`，一个用于指针，一个用于长度。