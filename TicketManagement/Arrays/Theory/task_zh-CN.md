一旦我们开始讨论“票据管理”，就需要考虑一种存储**多个**票据的方法。  
由此，我们需要考虑集合，特别是同质集合：  
我们希望存储多个相同类型的实例。

Rust 在这方面能提供什么呢？

## 数组

首先的尝试可以是使用一个**数组**。  
在 Rust 中，数组是固定大小的、包含同一类型元素的集合。

以下是定义数组的方法：

```rust
// 数组类型语法：[ <类型> ; <元素数量> ]
let numbers: [u32; 3] = [1, 2, 3];
```

这将创建一个包含三个整数的数组，并用值 `1`、`2` 和 `3` 初始化。  
该数组的类型是 `[u32; 3]`，可以读作“一个长度为 3 的 `u32` 数组”。

如果数组的所有元素都相同，可以使用更简短的语法初始化它：

```rust
// [ <值> ; <元素数量> ]
let numbers: [u32; 3] = [1; 3];
```

`[1; 3]` 创建了一个包含三个元素的数组，其中所有元素都等于 `1`。

### 访问元素

可以使用方括号访问数组中的元素：

```rust
let first = numbers[0];
let second = numbers[1];
let third = numbers[2];
```

索引类型必须是 `usize`。  
数组是**零索引**的，就像 Rust 中的其他内容一样。你可能之前已经在字符串切片和元组/类元组变体的字段索引中见过这个特性。

### 越界访问

如果尝试访问超出数组边界的元素，Rust 会发生 panic：

```rust
let numbers: [u32; 3] = [1, 2, 3];
let fourth = numbers[3]; // 这将引发 panic
```

这是通过运行时的**边界检查**强制执行的。这带来了一定的性能开销，但它能够防止缓冲区溢出。  
在某些场景下，Rust 编译器可以对边界检查进行优化，尤其是涉及迭代器时——我们稍后会详细讨论。

如果不希望程序发生 panic，可以使用 `get` 方法，它会返回一个 `Option<&T>`：

```rust
let numbers: [u32; 3] = [1, 2, 3];
assert_eq!(numbers.get(0), Some(&1));
// 如果试图访问越界索引，get 方法会返回 `None`，而不是发生 panic。
assert_eq!(numbers.get(3), None);
```

### 性能

由于数组的大小在编译时已知，编译器可以将其分配在栈中。  
如果运行下面的代码：

```rust
let numbers: [u32; 3] = [1, 2, 3];
```

你会得到如下的内存布局：

```text
        +---+---+---+
Stack:  | 1 | 2 | 3 |
        +---+---+---+
```

换句话说，数组的大小是 `std::mem::size_of::<T>() * N`，其中 `T` 是元素的类型，`N` 是元素的数量。  
你可以在 `O(1)` 时间内访问和替换数组中的每个元素。