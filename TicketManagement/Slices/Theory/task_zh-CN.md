## 切片（Slices）

让我们回到 `Vec` 的内存布局：

```rust
let mut numbers = Vec::with_capacity(3);
numbers.push(1);
numbers.push(2);
```

```text
      +---------+--------+----------+
栈    | pointer | length | capacity | 
      |  |      |   2    |    3     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+
堆：   | 1 | 2 | ? |
       +---+---+---+
```

我们已经提到过，`String` 其实只是 `Vec<u8>` 的一个伪装形式。\
这个相似性应该会让你想到："`&str` 对 `Vec` 的等效是什么？"

## `&[T]`

`[T]` 是一段连续的类型为 `T` 的元素的**切片**。\
它最常见的形式是它的借用形式，即 `&[T]`。

有多种方式可以从 `Vec` 创建切片引用：

```rust
let numbers = vec![1, 2, 3];
// 使用索引语法
let slice: &[i32] = &numbers[..];
// 使用方法
let slice: &[i32] = numbers.as_slice();
// 或者针对部分元素
let slice: &[i32] = &numbers[1..];
```

`Vec` 通过实现 `Deref` 特性（trait）并将 `[T]` 作为目标类型，因此你可以直接在 `Vec` 上使用切片方法，\
这归功于解引用强制（deref coercion）：

```rust
let numbers = vec![1, 2, 3];
// 惊喜！`iter` 不是 `Vec` 的方法！
// 这是 `&[T]` 的方法，但你可以直接在 `Vec` 上调用，
// 因为有解引用强制。
let sum: i32 = numbers.iter().sum();
```

### 内存布局

`&[T]` 是一个**胖指针**，和 `&str` 一样。\
它由一个指向切片首个元素的指针和切片长度组成。

如果你有一个包含三个元素的 `Vec`：

```rust
let numbers = vec![1, 2, 3];
```

然后创建一个切片引用：

```rust
let slice: &[i32] = &numbers[1..];
```

你会得到以下内存布局：

```text
                  numbers                          slice
      +---------+--------+----------+      +---------+--------+
栈    | pointer | length | capacity |      | pointer | length |
      |    |    |   3    |    4     |      |    |    |   2    |
      +----|----+--------+----------+      +----|----+--------+
           |                                    |  
           |                                    |
           v                                    | 
         +---+---+---+---+                      |
堆：     | 1 | 2 | 3 | ? |                      |
         +---+---+---+---+                      |
               ^                                |
               |                                |
               +--------------------------------+
```

### `&Vec<T>` 与 `&[T]`

当你需要将一个 `Vec` 的不可变引用传递给函数时，优先使用 `&[T]` 而不是 `&Vec<T>`。\
这使得该函数可以接受任何类型的切片，而不仅限于由 `Vec` 支撑的切片。

例如，你可以将 `Vec` 的部分元素传递给函数。\
但功能不仅限于此——你也可以传递一个**数组的切片**：

```rust
let array = [1, 2, 3];
let slice: &[i32] = &array;
```

数组切片与 `Vec` 切片是相同的类型：它们都是指向连续元素序列的胖指针。\
对于数组，指针指向的是栈上而不是堆上，但这并不影响切片的使用。