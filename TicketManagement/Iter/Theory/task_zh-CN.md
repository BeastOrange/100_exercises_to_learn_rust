## `.iter()`
##

`IntoIterator` **消耗** `self` 来创建一个迭代器。

这个方法有它的优势：你可以从迭代器中获取拥有所有权的值。
例如：如果你在一个 `Vec<Ticket>` 上调用 `.into_iter()`，你将得到一个返回 `Ticket` 值的迭代器。

这也存在一个缺点：在调用 `.into_iter()` 后，你将无法再使用原始的集合。
通常情况下，你希望在不消耗集合的情况下对它进行迭代，并查看值的**引用**。
以 `Vec<Ticket>` 为例，你可能希望迭代的是 `&Ticket` 类型的值。

大多数集合都会提供一个名为 `.iter()` 的方法，用来返回对集合元素的引用的迭代器。
例如：

```rust
let numbers: Vec<u32> = vec![1, 2];
// `n` 在这里的类型是 `&u32`
for n in numbers.iter() {
    // [...]
}
```

通过为**集合的引用**实现 `IntoIterator`，这个模式可以进一步简化。
在上面的例子中，那就是 `&Vec<Ticket>`。\
标准库已经实现了这个操作，因此以下代码可以正常运行：

```rust
let numbers: Vec<u32> = vec![1, 2];
// `n` 在这里的类型是 `&u32`
// 我们无需显式调用 `.iter()`
// 在 `for` 循环中直接使用 `&numbers` 就足够了
for n in &numbers {
    // [...]
}
```

按照惯例，应同时提供以下两种选项：

- 为集合的引用实现 `IntoIterator`。
- 提供一个 `.iter()` 方法，该方法返回对集合元素的引用的迭代器。

前者在 `for` 循环中使用时更加方便，后者更加显式并能用于其他上下文中。