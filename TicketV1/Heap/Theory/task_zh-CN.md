## 堆

栈非常棒，但它无法解决我们所有的问题。那么对于那些在编译时大小未知的数据怎么办呢？  
集合、字符串以及其他动态大小的数据无法（完全）分配在栈上。  
这就是**堆**发挥作用的地方。

## 堆分配

你可以将堆想象成一块大的内存区域——如果愿意，可以把它看作一个巨大的数组。  
每当你需要在堆上存储数据时，你可以向一个特殊的程序（**分配器**）请求为你保留堆的一部分。  
我们称这种交互（以及你保留的内存）为**堆分配**。  
如果分配成功，分配器会给你一个指向保留内存块起始位置的**指针**。

## 没有自动释放内存

堆的结构与栈大不相同。  
堆分配的内存块并不连续，它们可以位于堆中的任意位置。

```
+---+---+---+---+---+---+-...-+-...-+---+---+---+---+---+---+---+
|  分配块 1  | 空闲 | ... | ... |  分配块 N  |    空闲    |
+---+---+---+---+---+---+ ... + ... +---+---+---+---+---+---+---+
```

分配器的工作是跟踪堆中哪些部分被使用，哪些部分是空闲的。  
但是，分配器不会自动释放你分配的内存：你需要明确地释放不再需要的内存，  
通过再次调用分配器来**释放**它。

## 性能

堆的灵活性是有代价的：堆分配比栈分配**更慢**。  
这需要更多的维护工作！  
如果你阅读关于性能优化的文章，你会经常看到建议尽量减少堆分配，并在可能的情况下优先使用栈分配的数据。

## `String` 的内存布局

当你创建一个类型为 `String` 的局部变量时，Rust 被迫在堆上分配内存[^empty]：它无法预先知道你会放入多少文字，因此无法在栈上保留合适的空间。  
但 `String` 并不完全是在堆上分配的，它也会在栈上存储一些数据，特别是：

- 指向你预留的堆区域的**指针**。
- 字符串的**长度**，即字符串中的字节数。
- 字符串的**容量**，即在堆上预留的字节数。

让我们通过一个例子更好地理解这一点：

```rust
let mut s = String::with_capacity(5);
```

运行这段代码后，内存布局如下：

```
      +---------+--------+----------+
Stack | pointer | length | capacity | 
      |  |      |   0    |    5     |
      +--|------+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | ? | ? | ? | ? | ? |
       +---+---+---+---+---+
```

我们请求了一个最多可以容纳 5 个字节文本的 `String`。  
`String::with_capacity` 向分配器请求 5 个字节的堆内存。分配器返回一个指向该内存块起始位置的指针。  
但此时 `String` 是空的。在栈上，我们通过区分长度和容量来记录这个信息：  
这个 `String` 最多可以容纳 5 个字节，但当前仅包含 0 个字节的实际文本。

如果你向 `String` 中添加一些文本，情况将会发生变化：

```rust
s.push_str("Hey");
```

```
      +---------+--------+----------+
Stack | pointer | length | capacity |
      |  |      |   3    |    5     |
      +--|  ----+--------+----------+
         |
         |
         v
       +---+---+---+---+---+
Heap:  | H | e | y | ? | ? |
       +---+---+---+---+---+
```

`s` 现在包含了 3 个字节的文本。它的长度更新为 3，但容量仍然是 5。  
堆上的五个字节中有三个被用来存储字符 `H`、`e` 和 `y`。

### `usize`

我们在栈上需要多少空间来存储指针、长度和容量？  
这取决于你运行的机器的**架构**。

你的机器上的每个内存位置都有一个[**地址**](https://en.wikipedia.org/wiki/Memory_address)，通常表示为无符号整数。  
根据地址空间的最大大小（即你的机器可以寻址的内存大小），这个整数可以有不同的大小。  
大多数现代机器使用 32 位或 64 位地址空间。

Rust 通过提供类型 `usize` 来抽象掉这些与架构相关的细节：  
它是一个无符号整数，其大小等于你的机器上用于寻址内存所需的字节数。  
在 32 位机器上，`usize` 等价于 `u32`；在 64 位机器上，它等价于 `u64`。

容量、长度和指针在 Rust 中都用 `usize` 表示[^equivalence]。

### 堆上没有 `std::mem::size_of`

`std::mem::size_of` 返回一个类型在栈上占用的空间量，也称为**类型的大小**。

> 那么由 `String` 管理的那段堆内存缓冲区呢？这不是 `String` 的一部分大小吗？

不是！  
堆分配是由 `String` 管理的**资源**。  
编译器不认为它是 `String` 类型的一部分。

`std::mem::size_of` 不了解（或不在意）由某种类型通过指针管理或引用的额外堆分配数据，例如 `String` 的情况，因此它不会跟踪其大小。

遗憾的是，Rust 中没有等价于 `std::mem::size_of` 的工具来测量某个值在运行时分配的堆内存量。  
某些类型可能提供方法来查看其堆使用情况（例如 `String` 的 `capacity` 方法），  
但没有通用的“API”可以用来获取运行时堆使用情况。  
不过，你可以使用内存分析工具（例如 [DHAT](https://valgrind.org/docs/manual/dh-manual.html) 或 [自定义分配器](https://docs.rs/dhat/latest/dhat/)）来检查程序的堆使用情况。

[^empty]: 如果创建一个**空的** `String`（即 `String::new()`），`std` 不会进行分配。  
堆内存会在第一次向其中插入数据时保留。

[^equivalence]: 指针的大小也取决于操作系统。  
在某些环境中，指针的大小比内存地址**更大**（例如 [CHERI](https://web.archive.org/web/20240517051950/https://blog.acolyer.org/2019/05/28/cheri-abi/)）。  
Rust 简化地假设指针和内存地址的大小相同，这对于大多数你可能遇到的现代系统是成立的。