## 封装

现在我们对模块和可见性有了基本理解，接下来让我们回到**封装**的概念。\
封装是一种隐藏对象内部表示的实践。这通常用于强制对象状态的某些**不变性**。

回到我们的 `Ticket` 结构体：

```rust
struct Ticket {
    title: String,
    description: String,
    status: String,
}
```

如果所有字段都是公共的，就不存在封装。\
你必须假定这些字段可以在任何时候被修改，并且只要符合其类型的约束，就可以被设置为任意值。\
你无法排除一个工单可能会有一个空标题或一个不合理的状态值。

为了强制执行更严格的规则，我们必须将这些字段设为私有[^newtype]。\
然后，我们可以提供公共方法来与 `Ticket` 实例交互。\
这些公共方法将负责维护我们的不变性（例如，标题不能为空）。

如果至少有一个字段是私有的，就无法直接通过结构体实例化语法创建 `Ticket` 实例：

```rust
// 这将无法运行！
let ticket = Ticket {
    title: "Build a ticket system".into(),
    description: "A Kanban board".into(),
    status: "Open".into()
};
```

在之前关于可见性的练习中，你已经看过这一点了。\
现在我们需要提供一个或多个公共**构造器**——即可以在模块外部用于创建结构体新实例的静态方法或函数。\
好消息是我们已经有一个了：`Ticket::new`，这是在[验证课程](../../Validation/Theory/task.md)中实现的。

## 访问器方法

总结如下：

- 所有 `Ticket` 字段都是私有的
- 我们提供了一个公共构造器 `Ticket::new`，在创建时执行我们的验证规则

这只是一个良好的开始，但还不够：除了创建一个 `Ticket`，我们还需要与它交互。\
但是，如果字段是私有的，我们如何访问它们呢？

我们需要提供**访问器方法**。\
访问器方法是一些公共方法，它们允许你读取结构体中私有字段的值。

Rust 不像一些其他语言那样内置了为你生成访问器方法的能力。\
你需要自己编写它们——它们只是普通的方法。

[^newtype]: 或者通过细化它们的类型来实现，这是一种我们将在[后面的课程](../../../Ticket%20v2/Outro/Theory/task.md)中探讨的技巧。