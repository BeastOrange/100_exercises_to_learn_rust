## 内存布局

我们已经从操作的角度介绍了所有权和引用——了解了可以和不可以对它们进行的操作。  
现在是时候深入了解底层机制：让我们来谈谈**内存**。

## 栈和堆

在讨论内存时，你会常常听到人们提到**栈**和**堆**。  
它们是程序用于存储数据的两块不同的内存区域。

让我们从栈开始。

## 栈

**栈**是一个**LIFO**（后进先出，Last In, First Out）数据结构。  
当你调用函数时，一个新的**栈帧**会被添加到栈的顶部。这个栈帧用于存储  
该函数的参数、局部变量以及一些 "记录性" 值。  
当函数返回时，这个栈帧会从栈中移除[^stack-overflow]。

```text
+-----------------+
| frame for func1 |
+-----------------+
        |
        | func2 被调用
        v
+-----------------+
| frame for func2 |
+-----------------+
| frame for func1 |
+-----------------+
        |
        | func2 返回
        v
+-----------------+
| frame for func1 |
+-----------------+
```

从操作的角度来看，栈的分配和释放是**非常快速**的。  
我们总是从栈的顶部推入或弹出数据，因此不需要搜索可用的内存。  
我们也不必担心内存碎片：栈是一块连续的内存区域。

### Rust

Rust 通常会在栈上分配数据。  
在函数中有一个 `u32` 类型的输入参数？这 32 位会存储在栈上。  
你定义了一个 `i64` 类型的局部变量？这 64 位会存储在栈上。  
一切运行得非常顺利，因为这些整数的大小在编译时是已知的，因此编译后的程序知道需要为它们在栈上留出多少空间。

### `std::mem::size_of`

你可以使用 [`std::mem::size_of`](https://doc.rust-lang.org/std/mem/fn.size_of.html) 函数来验证某种类型在栈上占用的空间大小。

例如，对于一个 `u8`：

```rust
// 我们稍后会解释这个看起来有点奇怪的语法（`::<u8>`）。
// 现在可以先忽略。
assert_eq!(std::mem::size_of::<u8>(), 1);
```

结果是 1，这是可以理解的，因为 `u8` 是 8 位长，也就是 1 字节。

[^stack-overflow]: 如果你有嵌套的函数调用，每个函数在被调用时会将它的数据推到栈上，但只有在最内层函数返回时数据才会被弹出。  
如果嵌套函数调用太多，你可能会耗尽栈空间——栈不是无限的！  
这被称为[**栈溢出**](https://en.wikipedia.org/wiki/Stack_overflow)。