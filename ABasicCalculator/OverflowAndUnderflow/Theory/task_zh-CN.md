## 溢出

一个数的阶乘增长得非常快。  
例如，20 的阶乘是 2,432,902,008,176,640,000。这个值已经大于 32 位整数的最大值 2,147,483,647。

当一个算术操作的结果大于给定整数类型的最大值时，  
我们说这是一个**整数溢出**。

整数溢出是一个问题，因为它违反了算术操作的契约。  
两个特定类型的整数之间的算术操作结果应该是同一类型的另一个整数。  
但是**数学上正确的结果**无法适应该整数类型！

> 如果结果小于给定整数类型的最小值，我们将此事件称为**整数下溢**。  
> 为简洁起见，在本节余下内容中我们只讨论整数溢出，但请记住，  
> 我们所说的一切同样适用于整数下溢。
>
> 你在[“变量”一课](../../Variables/Theory/task.md)中编写的 `speed` 函数对于某些输入组合会发生下溢。  
> 例如，如果 `end` 小于 `start`，则 `end - start` 会导致 `u32` 类型下溢，  
> 因为结果本应是负数，而 `u32` 无法表示负数。

## 无自动提升

一种可能的方法是自动将结果提升到更大的整数类型。  
例如，如果你将两个 `u8` 整数相加，结果是 256（`u8::MAX + 1`），Rust 可以选择将结果解释为 `u16`，  
即能容纳 256 的下一个更大的整数类型。

但是，正如我们之前讨论过的那样，Rust 对类型转换相当严格。自动整数提升并不是 Rust 解决整数溢出问题的方法。

## 替代方案

由于我们排除了自动提升，那么当整数溢出发生时，我们可以做些什么呢？  
这可以归结为两种不同的方法：

- 拒绝操作  
- 提供一个适合预期整数类型的“合理”结果  

### 拒绝操作

这是最保守的方法：当发生整数溢出时，我们停止程序。  
这是通过 panic 完成的，这是我们在[“Panic”一课](../../Panics/Theory/task.md)中已经见过的机制。

### 提供一个“合理”结果

当算术操作的结果大于给定整数类型的最大值时，可以选择**环绕回绕**。  
如果你将特定整数类型的所有可能值看作一个圈，那么环绕回绕意味着当你达到最大值时，  
从最小值重新开始。

例如，如果你对 1 和 255（=`u8::MAX`）进行**环绕加法**，则结果是 0（=`u8::MIN`）。  
如果你使用有符号整数，同样的原则适用。例如，对 127（=`i8::MAX`）和 1 进行环绕相加，  
结果是 -128（=`i8::MIN`）。

## `overflow-checks`

Rust 允许开发者选择当发生整数溢出时使用哪种方法。  
此行为由 `overflow-checks` 配置设置控制。

如果 `overflow-checks` 设置为 `true`，Rust 会在运行时整数操作溢出时**panic**。  
如果 `overflow-checks` 设置为 `false`，Rust 会在整数操作溢出时**环绕回绕**。

你可能会问——什么是配置设置？我们来深入了解一下！

## 配置

[**配置**](https://doc.rust-lang.org/cargo/reference/profiles.html)是一组用于定制 Rust 代码编译方式的配置选项。

Cargo 提供了 4 个内置配置：`dev`、`release`、`test` 和 `bench`。  
`dev` 配置在每次运行 `cargo build`、`cargo run` 或 `cargo test` 时使用。它面向本地开发，  
因此牺牲了运行时性能以获得更快的编译时间和更好的调试体验。  
而 `release` 配置则针对运行时性能进行了优化，但会导致更长的编译时间。你需要通过  
显式请求 `--release` 标志来启用，例如 `cargo build --release` 或 `cargo run --release`。  
`test` 配置是运行 `cargo test` 时的默认配置，它继承自 `dev` 配置。  
`bench` 配置是运行 `cargo bench` 的默认配置，它继承自 `release` 配置。  
使用 `dev` 进行迭代开发和调试，使用 `release` 进行优化的生产构建，  
使用 `test` 进行正确性测试，使用 `bench` 进行性能基准测试。

> “你是否以 release 模式构建了你的项目？”几乎是 Rust 社区的一个梗。  
> 它指的是那些不熟悉 Rust 的开发者在社交媒体上抱怨性能问题（例如 Reddit、Twitter），  
> 然后才意识到自己没有使用 release 模式构建项目。

你也可以定义自定义配置或对内置配置进行自定义。

### `overflow-check`

默认情况下，`overflow-checks` 设置为：

- `true`：对于 `dev` 配置  
- `false`：对于 `release` 配置  

这是符合这两种配置目标的。  
`dev` 旨在本地开发，因此通过 panic 尽早高亮潜在问题。  
而 `release` 被调整为运行时性能：溢出检查会降低程序速度，因此优先选择环绕回绕。

然而，在这两种配置之间行为的不同可能会导致微妙的 bug。  
我们的建议是对两种配置都启用 `overflow-checks`：相比起产生错误结果，崩溃更好。  
在大多数情况下，这对运行时性能的影响是微乎其微的；如果你正在开发性能关键的应用程序，  
可以运行基准测试来决定是否可以接受。

`overflow-checks` 是一个笨重的工具：它是一个全局设置，会影响整个程序。  
通常，你可能希望根据上下文以不同方式处理整数溢出：有时环绕是正确的选择，  
有时 panic 更合适。

## `wrapping_` 方法

你可以通过使用 `wrapping_` 方法在每次操作的基础上选择环绕算术。  
例如，可以使用 `wrapping_add` 来通过环绕将两个整数相加：

```rust
let x = 255u8;
let y = 1u8;
let sum = x.wrapping_add(y);
assert_eq!(sum, 0);
```

## 延伸阅读

- 查看 [“关于 Rust 中整数溢出的谣言与传说”](https://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/)，  
  了解关于整数溢出的深入讨论。