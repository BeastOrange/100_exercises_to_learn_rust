## 类型转换与 `as` 强制类型转换

我们已经多次重复提到，Rust 不会为整数执行隐式类型转换。\
那么，你如何进行_显式_类型转换呢？

## `as`

你可以使用 `as` 运算符在整数类型之间进行转换。\
`as` 转换是**无错误**的。

例如：

```rust
let a: u32 = 10;

// 将 `a` 强制转换为 `u64` 类型
let b = a as u64;

// 如果编译器可以正确推断出目标类型
// 你可以使用 `_` 表示目标类型。例如：
let c: u64 = a as _;
```

这种转换的语义符合你的预期：所有 `u32` 值在 `u64` 中都是有效的。

### 截断

如果我们反过来，从更大的整数类型转为更小的类型，事情会变得有趣：

```rust
// 一个数值过大
// 无法适配到 `u8`
let a: u16 = 255 + 1;
let b = a as u8;
```

这个程序会正常运行，因为 `as` 转换是无错误的。\
但是，`b` 的值是多少呢？\
当从更大的整数类型转换为更小的类型时，Rust 编译器会进行**截断**。

为了理解发生了什么，让我们看看 `256u16` 在内存中的表示形式，即一个位序列：

```text
 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0
|               |               |
+---------------+---------------+
  前8位           后8位
```

当转换为 `u8` 时，Rust 编译器会保留 `u16` 内存表示的后8位：

```text
 0 0 0 0 0 0 0 0 
|               |
+---------------+
  后8位
```

因此，`256 as u8` 等于 `0`。这在大多数情况下……并不理想。\
实际上，如果 Rust 编译器发现你尝试转换一个会导致截断的文字值，
它会主动尝试阻止你：

```text
error: literal out of range for `i8`
  |
4 |     let a = 255 as i8;
  |             ^^^
  |
  = note: the literal `255` does not fit into the type `i8` 
          whose range is `-128..=127`
  = help: consider using the type `u8` instead
  = note: `#[deny(overflowing_literals)]` on by default
```

### 建议

作为经验法则，对于 `as` 强制类型转换要非常小心。\
**仅**在从较小类型转换为较大类型时使用它。\
如果是从较大的整数类型转换为较小类型，可以依赖于[_可能失败_的转换机制](../../../Ticket%20v2/TryFrom%20trait/Theory/task.md)，
我们将在课程的后续部分中探讨。

### 局限性

令人惊讶的行为并不是 `as` 强制类型转换的唯一缺点。\
它还存在一定的局限性：你只能依赖 `as` 转换原生类型和其他一些特殊情况。\
当处理组合类型时，你必须依赖不同的转换机制（[可能失败的](../../../Ticket%20v2/TryFrom%20trait/Theory/task.md) 和 [无错误的](../../../Traits/From%20trait/Theory/task.md)，我们将在后续内容中具体探讨）。

## 拓展阅读

- 查看 [Rust 官方文档](https://doc.rust-lang.org/reference/expressions/operator-expr.html#numeric-cast)，
  了解每种来源/目标组合的 `as` 转换的精确行为，
  以及允许转换的完整清单。