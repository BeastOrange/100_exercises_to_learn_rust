## 变量

在 Rust 中，可以使用关键字 `let` 来声明**变量**。\
例如：

```rust
let x = 42;
```

上面我们定义了一个变量 `x`，并将其赋值为 `42`。

## 类型

在 Rust 中，每个变量都必须有一个类型。变量的类型可以由编译器推导，也可以由开发者显式指定。

### 显式类型注解

可以通过在变量名后添加一个冒号 `:` 和类型来显式指定变量的类型。例如：

```rust
// let <variable_name>: <type> = <expression>;
let x: u32 = 42;
```

在上面的例子中，我们显式地将变量 `x` 的类型限定为 `u32`。

### 类型推导

如果我们不指定变量的类型，编译器会根据变量的使用上下文尝试推导其类型。

```rust
let x = 42;
let y: u32 = x;
```

在上面的例子中，我们没有指定 `x` 的类型。\
后来将 `x` 赋值给了显式声明为 `u32` 类型的 `y`。由于 Rust 不进行自动类型转换，编译器推导出 `x` 的类型为 `u32`，即与 `y` 相同，从而允许程序在没有错误的情况下进行编译。

### 推导的局限性

有时，编译器需要一些额外的帮助来根据变量的使用推导出正确的类型。\
在这种情况下，您会遇到编译错误，编译器会要求您提供一个显式的类型提示以消除歧义。

## 函数参数是变量

并非所有英雄都会披风，也并非所有变量都是通过 `let` 声明的。\
函数的参数也是变量！

```rust
fn add_one(x: u32) -> u32 {
    x + 1
}
```

在上面的例子中，`x` 是一个类型为 `u32` 的变量。\
函数参数和通过 `let` 声明的变量唯一的不同点在于：函数参数**必须**显式声明其类型，编译器不会为您推导类型。\
这种约束使得 Rust 的编译器（以及人类开发者！）可以在无需查看函数实现的情况下理解函数的签名。对于编译速度来说，这是一大提升[^speed]！

## 初始化

在声明变量时，不必须立刻初始化它。\
例如：

```rust
let x: u32;
```

是一个有效的变量声明。\
不过，在使用变量之前，必须对其进行初始化。如果没有初始化，编译器会抛出一个错误：

```rust
let x: u32;
let y = x + 1;
```

会抛出一个编译错误：

```text
error[E0381]: used binding `x` isn't initialized
 --> src/main.rs:3:9
  |
2 | let x: u32;
  |     - binding declared here but left uninitialized
3 | let y = x + 1;
  |         ^ `x` used here but it isn't initialized
  |
help: consider assigning a value
  |
2 | let x: u32 = 0;
  |            +++
```

[^speed]: Rust 编译器在提高编译速度方面需要尽可能多的帮助。