## 基本类型

`u32` 是 Rust 中的一种**基本类型**。基本类型是语言中最基本的构建块。  
它们是内置于语言本身的——即它们不是基于其他类型定义的。

你可以将这些基本类型组合起来创建更复杂的类型。我们很快就会看到如何实现。

## 整数

特别地，`u32` 是一种**无符号的 32 位整数**。

整数是可以用没有小数部分的数字表示的数。例如，`1` 是一个整数，而 `1.2` 不是。

### 有符号与无符号

整数可以是**有符号**或**无符号**的。  
无符号整数只能表示非负数（即 `0` 或更大）。  
有符号整数可以表示正数和负数两种（例如 `-1`、`12` 等）。

`u32` 中的 `u` 代表**无符号**。  
对应的有符号整数类型是 `i32`，其中 `i` 代表整数（即任何整数，正或负）。

### 位宽

`u32` 中的 `32` 表示用于在内存中表示数字的**位数[^bit]**。  
位数越多，可以表示的数字范围越大。

Rust 支持多种整数的位宽：`8`、`16`、`32`、`64`、`128`。

使用 32 位时，`u32` 可以表示的数字范围是从 `0` 到 `2^32 - 1`（也就是 [`u32::MAX`](https://doc.rust-lang.org/std/primitive.u32.html#associatedconstant.MAX)）。  
使用相同的位数，有符号整数（`i32`）可以表示的数字范围是从 `-2^31` 到 `2^31 - 1`  
（即从 [`i32::MIN`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MIN) 到 [`i32::MAX`](https://doc.rust-lang.org/std/primitive.i32.html#associatedconstant.MAX)）。  
`i32` 的最大值比 `u32` 的最大值小，因为需要使用一个位来表示数字的符号。关于有符号整数在内存中的表示方法，请查看 [二进制补码](https://en.wikipedia.org/wiki/Two%27s_complement) 相关文档。

### 总结

通过结合两个变量（有符号/无符号和位宽），我们得到以下整数类型：

| 位宽  | 有符号 | 无符号 |
| ----- | ------ | ------ |
| 8 位  | `i8`   | `u8`   |
| 16 位 | `i16`  | `u16`  |
| 32 位 | `i32`  | `u32`  |
| 64 位 | `i64`  | `u64`  |
| 128 位| `i128` | `u128` |

## 字面量

**字面量**是在源代码中表示固定值的符号。  
例如，`42` 是表示数字 42 的 Rust 字面量。

### 字面量的类型注解

但 Rust 中所有的值都有一个类型，那么……`42` 的类型是什么？

Rust 编译器会尝试根据字面量的使用方式推断它的类型。  
如果你没有提供上下文，编译器会将整数字面量默认设置为 `i32` 类型。  
如果你想使用其他类型，则可以在字面量后添加所需的整数类型作为后缀——例如 `2u64` 表示类型为 `u64` 的 `2`。

### 字面量中的下划线

你可以使用下划线 `_` 来提高大数字的可读性。  
例如，`1_000_000` 与 `1000000` 是相同的值。

## 算术运算符

Rust 为整数支持以下算术运算符[^traits]：

- `+` 表示加法
- `-` 表示减法
- `*` 表示乘法
- `/` 表示除法
- `%` 表示取余

这些运算符的优先级与数学中的规则相同。  
你可以使用括号来覆盖默认的优先级，例如 `2 * (3 + 4)`。

> ⚠️ **注意**
>
> 当用于整数类型时，除法运算符 `/` 执行整数除法。  
> 即结果向零截断。例如，`5 / 2` 是 `2`，而不是 `2.5`。

## 无自动类型转换

正如我们在前面的练习中讨论过的，Rust 是一种静态类型的语言。  
尤其是，Rust 对类型转换非常严格。它不会自动将一个类型的值转换为另一个类型[^coercion]，即使该转换是无损的。你必须显式进行转换。

例如，你不能将一个 `u8` 值分配给一个类型为 `u32` 的变量，即使所有 `u8` 的值都是有效的 `u32` 值：

```rust
let b: u8 = 100;
let a: u32 = b;
```

这样会抛出编译错误：

```text
error[E0308]: mismatched types
  |
3 |     let a: u32 = b;
  |            ---   ^ expected `u32`, found `u8`
  |            |
  |            expected due to this
  |
```

我们会在课程的[后面章节](../../../Traits/From%20trait/Theory/task.md)中学习如何在类型之间进行转换。

## 延伸阅读

- 官方 Rust 书中[整数类型章节](https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-types)

[^bit]: 位是计算机中数据的最小单位。它只能有两个值：`0` 或 `1`。

[^traits]: Rust 不允许定义自定义运算符，但它允许你控制内置运算符的行为。  
我们将在课程的[后续章节](../../../Traits/Operator%20overloading/Theory/task.md)中讨论运算符重载，前提是你已经学习了 traits。

[^coercion]: 在该规则上有一些例外，主要与引用、智能指针和语法便利性有关。我们将在[后续章节](../../../Traits/Deref%20trait/Theory/task.md)中介绍相关内容。  
在此期间，“所有转换都是显式的” 这一思维方式会对你有所帮助。