## 运行时架构

到目前为止，我们一直在将异步运行时作为一个抽象概念讨论。  
让我们更深入地了解它们的实现方式——正如你很快会看到的，这对我们的代码会产生一定的影响。

## 类型

`tokio` 提供了两种不同的运行时**类型**。

您可以通过 `tokio::runtime::Builder` 配置运行时：

- `Builder::new_multi_thread` 会为您提供一个 **多线程的 `tokio` 运行时**
- `Builder::new_current_thread` 则依赖 **当前线程** 来执行任务。

`#[tokio::main]` 默认返回一个多线程运行时，而  
`#[tokio::test]` 直接使用当前线程运行时。

### 当前线程运行时

当前线程运行时，顾名思义，完全依赖启动时运行的操作系统线程来调度和执行任务。  
当使用当前线程运行时时，您会有**并发性**，但没有**并行性**：  
异步任务会交替执行，但在任何给定时刻最多只有一个任务在运行。

### 多线程运行时

而使用多线程运行时时，在任何给定时刻最多可能有 `N` 个任务**并行**运行，  
其中 `N` 是运行时使用的线程数量。默认情况下，`N` 与可用 CPU 核心数相同。

不仅如此：`tokio` 实现了**工作窃取**机制。  
如果一个线程处于空闲状态，它不会继续等待；而是会尝试找到一个新的、已准备好执行的任务，  
可能取自全局队列，也可能从另一个线程的本地队列窃取任务。  
工作窃取在处理线程间任务负载不均的场景时，尤其是在降低尾部延迟上，  
能够显著提升性能。

## 含义

`tokio::spawn` 是与运行时类型无关的：无论您使用的是多线程还是当前线程运行时，它都可以正常工作。  
缺点是，它的签名假设了最糟情况（即多线程运行时），因此受到相应的约束：

```rust
pub fn spawn<F>(future: F) -> JoinHandle<F::Output>
where
    F: Future + Send + 'static,
    F::Output: Send + 'static,
{ /* */ }
```

现在先忽略 `Future` trait，我们来关注其他部分。  
`spawn` 要求所有输入都必须是 `Send` 的，并且具有 `'static` 生命周期。

`'static` 限制与 `std::thread::spawn` 上的 `'static` 限制遵循相同的逻辑：  
被 spawn 的任务可能会比其创建的上下文存活得更久，  
因此它不应依赖于任何在上下文销毁后可能被释放的局部数据。

```rust
fn spawner() {
    let v = vec![1, 2, 3];
    // 这段代码无法正常工作，因为 `&v` 的
    // 生命周期不足够长。
    tokio::spawn(async {
        for x in &v {
            println!("{x}")
        }
    })
}
```

另一方面，`Send` 是 `tokio` 工作窃取策略的直接结果：  
在线程 `A` 上被 spawn 的任务可能会因为线程 `B` 空闲而被移至线程 `B`，  
因此需要 `Send` 限制，因为任务跨越了线程边界。

```rust
fn spawner(input: Rc<u64>) {
    // 这段代码同样无法正常工作，因为
    // `Rc` 不是 `Send` 的。
    tokio::spawn(async move {
        println!("{}", input);
    })
}