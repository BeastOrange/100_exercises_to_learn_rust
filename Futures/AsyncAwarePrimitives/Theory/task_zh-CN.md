## 支持异步的原语

当你浏览 `tokio` 的文档时，你会注意到它提供了许多类型，这些类型“反映”了标准库中的类型，但带有异步特性：锁、通道、计时器等等。

在异步上下文中工作时，你应该优先使用这些异步替代品，而不是它们的同步版本。

为了理解原因，让我们看看上一章中提到的互斥锁 `Mutex`。

## 案例研究：`Mutex`

以下是一个简单的示例：

```rust
use std::sync::{Arc, Mutex};

async fn run(m: Arc<Mutex<Vec<u64>>>) {
    let guard = m.lock().unwrap();
    http_call(&guard).await;
    println!("Sent {:?} to the server", &guard);
    // `guard` 在这里被释放
}

/// 使用 `v` 作为 HTTP 调用的请求体。
async fn http_call(v: &[u64]) {
  // [...]
}
```

### `std::sync::MutexGuard` 和切换点

这段代码可以编译，但存在风险。

我们尝试在异步上下文中获取 `std` 中的 `Mutex` 的锁，然后在跨越切换点（`http_call` 的 `.await`）时持有得到的 `MutexGuard`。

假设有两个任务在单线程运行时环境中并发执行 `run`。我们观察到如下调度事件的顺序：

```text
     任务 A          任务 B
        | 
  获取锁
切换到运行时
        | 
        +--------------+
                       |
              尝试获取锁
```

发生了死锁。任务 B 永远无法获取锁，因为锁当前被任务 A 持有，而任务 A 在释放锁之前切换到运行时，且由于运行时无法抢占任务 B，任务 A 无法被重新调度。

### `tokio::sync::Mutex`

通过切换到 `tokio::sync::Mutex`，可以解决这个问题：

```rust
use std::sync::Arc;
use tokio::sync::Mutex;

async fn run(m: Arc<Mutex<Vec<u64>>>) {
    let guard = m.lock().await;
    http_call(&guard).await;
    println!("Sent {:?} to the server", &guard);
    // `guard` 在这里被释放
}
```

现在获取锁是一个异步操作，如果无法继续执行，它会切换回运行时。\
回到前面的场景，下面会发生：

```text
       任务 A          任务 B
          | 
  获取锁
开始执行 `http_call`
切换到运行时
          | 
          +--------------+
                         |
              尝试获取锁
               无法获取锁
                 切换到运行时
                         |
          +--------------+
          |
`http_call` 完成      
释放锁
  切换到运行时
          |
          +--------------+
                         |
                 获取锁
                       [...]
```

一切正常！

### 多线程环境下也无法避免问题

在前面的示例中，我们使用了单线程运行时作为执行上下文，但即使使用多线程运行时，也存在相同的风险。\
唯一的区别在于导致死锁所需的并发任务数量：在单线程运行时中，需要 2 个任务；在多线程运行时中，需要 `N+1` 个任务，其中 `N` 是运行时线程的数量。

### 缺点

使用支持异步的 `Mutex` 会带来性能损失。\
如果你确信锁不会存在显著竞争，**并且**你能够谨慎地避免在跨越切换点时持有锁，那么即使在异步上下文中，你仍然可以使用 `std::sync::Mutex`。

但需要权衡性能收益与可能遇到的活跃性风险。

## 其他原语

我们使用了 `Mutex` 作为示例，但相同的原则也适用于 `RwLock`、信号量等。\
在异步上下文中，请优先选择支持异步的版本，以尽量减少问题风险。