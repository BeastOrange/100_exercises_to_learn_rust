## 异步函数

到目前为止，你编写的所有函数和方法都是“即时执行”的。\
在调用它们之前，没有任何事情会发生。但一旦调用，它们会运行到完成：\
完成**所有**工作后，再返回结果。

有时候，这种行为并不理想。\
例如，当你在编写一个 HTTP 服务器时，可能会有大量的**等待**：\
等待请求体到达、等待数据库响应、等待下游服务回复等等。

如果在等待时，你能够做一些其他事情会怎么样？\
如果你可以在计算过程中途放弃会怎么样？\
如果你可以选择优先处理另一个任务，而暂停当前任务会怎么样？

这就是**异步函数**的用武之地。

## `async fn`

你可以使用 `async` 关键字定义一个异步函数：

```rust
use tokio::net::TcpListener;

// 这个函数是异步的
async fn bind_random() -> TcpListener {
    // [...]
}
```

如果你像调用常规函数一样调用 `bind_random`，会发生什么？

```rust
fn run() {
    // 调用 `bind_random`
    let listener = bind_random();
    // 接下来呢？
}
```

什么也没发生！\
Rust 不会像调用其他语言中的后台任务一样，在调用时就开始执行 `bind_random`。\
Rust 中的异步函数是**惰性**的：除非明确要求它们执行工作，否则它们不会做任何事情。\
使用 Rust 的术语，我们说 `bind_random` 返回一个**未来值**，即一个可能会稍后完成的计算。它们被称为“未来值”，是因为它们实现了 `Future` 特性。在本章后面，我们将详细研究这一接口。

## `.await`

让异步函数执行工作的最常见方法是使用 `.await` 关键字：

```rust
use tokio::net::TcpListener;

async fn bind_random() -> TcpListener {
    // [...]
}

async fn run() {
    // 调用 `bind_random` 并等待它完成
    let listener = bind_random().await;
    // 现在 `listener` 已准备好
}
```

`.await` 不会将控制权返回给调用者，直到异步函数完成其运行——例如，上例中直到 `TcpListener` 被创建。

## 运行时

如果你感到困惑，这是正常的！\
我们刚刚说了异步函数的好处是它们不会一次性完成**所有**工作。然后我们引入了 `.await`，然而 `.await` 又直到异步函数运行完成才返回。我们好像重新引入了最初试图解决的问题？那这么做到底有什么意义？

并非如此！调用 `.await` 时，在幕后发生了很多事情！\
你将控制权交给了一个**异步运行时**，也被称为**异步执行器**。\
执行器是实现这些魔法的地方：它们负责管理所有正在进行的异步**任务**。具体来说，它们需要平衡以下两个目标：

- **进度**：确保任务在条件满足的情况下能够继续进行。
- **效率**：如果某个任务在等待某些东西，它们会试图让其他任务在此期间运行，从而充分利用可用资源。

### 没有默认运行时

Rust 在异步编程方面的做法相当独特：\
它没有默认的运行时。标准库并未自带一个运行时。你需要选择并引入自己的运行时！

在大多数情况下，你会选择生态系统中可用的其中一个选项。\
一些运行时被设计为广泛适用，对大多数应用程序来说是一个可靠的选择，例如 `tokio` 和 `async-std` 就属于这一类。\
其他运行时则针对特定用例进行了优化，例如用于嵌入式系统的 `embassy`。

在整个课程中，我们将依赖 `tokio`，这是 Rust 通用异步编程中最受欢迎的运行时。

### `#[tokio::main]`

可执行程序的入口点，即 `main` 函数，必须是同步函数。\
你需要在这里设置并启动选择的异步运行时。

大多数运行时都提供了一个宏以简化此过程。对于 `tokio`，这个宏是 `tokio::main`：

```rust
#[tokio::main]
async fn main() {
    // 你的异步代码写在这里
}
```

它展开后相当于：

```rust
fn main() {
    let rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(
        // 你的异步函数写在这里
        // [...]
    );
}
```

### `#[tokio::test]`

同样的逻辑也适用于测试：它们必须是同步函数。\
每个测试函数会在自己的线程中运行，如果你在测试中需要运行异步代码，\
你需要负责设置并启动一个异步运行时。\
`tokio` 提供了一个 `#[tokio::test]` 宏来简化这一过程：

```rust
#[tokio::test]
async fn my_test() {
    // 你的异步测试代码写在这里
}