## 不要阻塞运行时

让我们回到关键的让步点。\
与线程不同，**Rust 的任务不能被抢占**。

`tokio` 本身无法决定暂停一个任务并运行另一个任务。\
只有当任务让出控制权时（即当 `Future::poll` 返回 `Poll::Pending` 或当 `async fn` 中使用 `.await` 一个 future 时），控制才会专门交回给执行器。

这让运行时有一种风险：如果一个任务从不让出控制权，那么运行时将永远无法运行其他任务。这被称为**阻塞运行时**。

## 什么是阻塞？

多长时间才算太久？一个任务在不让出控制权的情况下可以运行多长时间而不会成为问题？

这取决于运行时、应用程序、任务的并发数量以及许多其他因素。但作为一个通用的经验法则，尝试在每次让步点之间花费少于 100 微秒的时间。

## 后果

阻塞运行时可能导致：

- **死锁**：如果没有让步的任务正在等待另一个任务完成，而另一个任务又在等待第一个任务让步，那么就会发生死锁。在这种情况下，除非运行时能够在其他线程上调度任务，否则无法继续推进。
- **饥饿**：其他任务可能无法运行，或者可能在长时间的延迟后才开始运行，这会导致性能低下（例如高尾延迟）。

## 阻塞并不总是显而易见的

某些类型的操作在异步代码中通常应避免，例如：

- 同步 I/O。你无法预测它将需要多长时间，而且很可能超过 100 微秒。
- 高耗时的 CPU 密集型计算。

但后一类情况并不总是显而易见。例如，排序一个只有少量元素的向量没问题；但如果向量包含数十亿个条目，情况就完全不同了。

## 如何避免阻塞

那么，如果假设你**必须**执行一个符合或可能符合阻塞定义的操作，该如何避免阻塞运行时？\
你需要将工作移到其他线程上。你不应该使用运行时线程（即，`tokio` 用来运行任务的那些线程）。

`tokio` 为此目的提供了一个专用的线程池，称为**阻塞池**。你可以使用 `tokio::task::spawn_blocking` 函数在阻塞池中启动同步操作。`spawn_blocking` 返回一个 future，当操作完成时，它会解析为操作的结果。

```rust
use tokio::task;

fn expensive_computation() -> u64 {
    // [...]
}

async fn run() {
    let handle = task::spawn_blocking(expensive_computation);
    // 同时处理其他事务
    let result = handle.await.unwrap();
}
```

阻塞池是长期存在的。与直接通过 `std::thread::spawn` 创建新线程相比，使用 `spawn_blocking` 通常更快，因为线程初始化的成本被摊分到多个调用中。

## 进一步阅读

- 查看 [Alice Ryhl 的博客文章](https://ryhl.io/blog/async-what-is-blocking/) 了解更多相关主题内容。