## 出错的可能性

让我们重新审视前一个练习中的 `Ticket::new` 函数：

```rust
impl Ticket {
    pub fn new(
        title: String, 
        description: String, 
        status: Status
    ) -> Ticket {
        if title.is_empty() {
            panic!("标题不能为空");
        }
        if title.len() > 50 {
            panic!("标题长度不能超过 50 字节");
        }
        if description.is_empty() {
            panic!("描述不能为空");
        }
        if description.len() > 500 {
            panic!("描述长度不能超过 500 字节");
        }

        Ticket {
            title,
            description,
            status,
        }
    }
}
```

一旦某个检查失败，该函数就会触发 panic（恐慌）。  
这并不理想，因为它没有给调用者一个**处理错误**的机会。

现在是时候引入 `Result` 类型了，这是 Rust 的主要错误处理机制。

## `Result` 类型

`Result` 类型是标准库中定义的一个枚举：

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

它有两个变体：

- `Ok(T)`：表示操作成功。包含 `T`，即操作的输出结果。
- `Err(E)`：表示操作失败。包含 `E`，即发生的错误。

`Ok` 和 `Err` 都是泛型，你可以为成功和失败的情况指定自己的类型。

## 没有异常

在 Rust 中，可恢复的错误被**表示为值**。  
它们只是某种类型的实例，可以像其他值一样被传递和操作。  
这与其他语言（如 Python 或 C#）有很大的不同，这些语言使用**异常**来表示错误。

异常创建了一个单独的控制流路径，这可能会导致难以理解的代码。  
仅通过查看函数的签名，你无法知道它是否会抛出异常。  
你也无法知道，仅通过函数签名，**哪些**异常类型可能被抛出。  
你必须查看函数的文档或其实现才能找出答案。

异常处理逻辑的局部性非常差：抛出异常的代码远离捕获异常的代码，且两者之间没有直接的联系。

## 出错的可能性被编码到类型系统中

Rust 使用 `Result`，强制你在**函数签名中明确表达失败的可能性**。  
如果一个函数可能失败（并且你希望调用者有机会处理错误），则它必须返回一个 `Result`。

```rust
// 仅通过函数签名，你就知道该函数可能会失败。
// 你还可以检查 `ParseIntError`，以了解可能会发生哪些错误类型。
fn parse_int(s: &str) -> Result<i32, ParseIntError> {
    // ...
}
```

这是 `Result` 的一个重大优势：它使失败的可能性显而易见。

但请记住，panic 是存在的。它们并不被类型系统追踪，就像其他语言中的异常一样。  
然而，panic 是为了表示**不可恢复的错误**，应该尽量少用。