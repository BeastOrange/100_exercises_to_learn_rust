## 库和二进制文件

实现 `TicketNewError` 的 `Error` 特性需要一些代码，不是吗？\
一个手动的 `Display` 实现，以及一个 `Error` 的实现块。

我们可以通过使用[`thiserror`](https://docs.rs/thiserror/latest/thiserror/)，减少一些样板代码，\
这是一个 Rust 的 crate（模块），它提供了一个**过程宏**，用于简化自定义错误类型的创建。\
但我们稍稍走得有点远了：`thiserror` 是一个第三方 crate，会是我们的第一个依赖项！

在深入讨论依赖关系之前，让我们先退一步，谈谈 Rust 的打包系统。

## 什么是包？

一个 Rust 包由 `Cargo.toml` 文件中的 `[package]` 部分定义，也被称为其**清单**。\
在 `[package]` 部分中，你可以设置包的元数据，比如它的名称和版本。

去看看这一部分练习目录中的 `Cargo.toml` 文件吧！

## 什么是 crate？

在一个包内，你可以包含一个或多个**crate**（也叫作**目标**）。\
两种最常见的 crate 类型是**二进制 crate**和**库 crate**。

### 二进制文件

二进制文件是可以编译为**可执行文件**的程序。\
它必须包含一个名为 `main` 的函数——即程序的入口点。`main` 会在程序执行时被调用。

### 库

另一方面，库本身是不可执行的。你不能**运行**一个库，\
但你可以从另一个依赖它的包中**导入它的代码**。\
库将代码（如函数、类型等）组织在一起，可以被其他包作为**依赖项**利用。

到目前为止，你已经解决的所有练习都被构建为带有测试套件的库。

### 约定

关于 Rust 包，有一些需要牢记的约定：

- 包的源码通常位于 `src` 目录。
- 如果有一个 `src/lib.rs` 文件，`cargo` 会推断出该包包含一个库 crate。
- 如果有一个 `src/main.rs` 文件，`cargo` 会推断出该包包含一个二进制 crate。

你可以通过在 `Cargo.toml` 文件中显式声明目标来覆盖这些默认设置——更多详细信息请参阅\
[`cargo` 的文档](https://doc.rust-lang.org/cargo/reference/cargo-targets.html#cargo-targets)。

请记住，虽然一个包可以包含多个 crate，但它只能包含一个库 crate。