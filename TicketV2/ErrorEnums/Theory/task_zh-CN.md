## 错误枚举

您在上一练习中解决问题的方式可能感觉有些别扭：匹配字符串并不是理想的选择！\
同事可能会重新编写 `Ticket::new` 返回的错误信息（例如，提高可读性），这样，您的调用代码可能会突然失效。

您已经知道可以解决此问题的机制：枚举！

## 响应错误

当您希望根据具体发生的错误让调用方采取不同行为时，可以使用枚举来表示不同的错误情况：

```rust
// 一个错误枚举，用于表示从字符串解析 `u32` 时可能发生的不同错误情况。
enum U32ParseError {
    NotANumber, // 不是数字
    TooLarge,   // 超出范围
    Negative,   // 为负值
}
```

使用错误枚举，您可以在类型系统中编码不同的错误情况——它们成为可失败函数签名的一部分。\
这简化了调用方的错误处理，因为他们可以使用 `match` 表达式来响应不同的错误情况：

```rust
match s.parse_u32() {
    Ok(n) => n,
    Err(U32ParseError::Negative) => 0, // 错误：为负值
    Err(U32ParseError::TooLarge) => u32::MAX, // 错误：超出范围
    Err(U32ParseError::NotANumber) => { // 错误：不是数字
        panic!("Not a number: {}", s);
    }
}