## 通道

到目前为止，我们启动的线程生命周期都较短。  
获取一些输入，运行计算，返回结果，然后关闭。

对于我们的票务管理系统，我们想要做一些不同的事情：  
一个客户端-服务器架构。

我们将拥有**一个长期运行的服务器线程**，负责管理我们的状态，即存储的票务信息。

然后我们将有**多个客户端线程**。  
每个客户端都能够向有状态线程发送**命令**和**查询**，以更改其状态（例如，添加一个新票据）或检索信息（例如，获取一个票据的状态）。  
客户端线程将并发运行。

## 通信

到目前为止，我们只进行了非常有限的父子线程通信：

- 启动的线程从父上下文中借用/消费数据
- 启动的线程在连接（join）时将数据返回给父线程

这种模式不足以支持客户端-服务器设计。  
客户端需要能够在服务器线程**启动之后**与其发送和接收数据。

我们可以使用**通道**来解决这个问题。

## 通道

Rust 的标准库在其 `std::sync::mpsc` 模块中提供了**多生产者-单消费者**（mpsc）通道。  
通道有两种类型：有界和无界。我们现在会使用无界版本，但稍后会讨论这两者的优缺点。

通道的创建方式如下：

```rust
use std::sync::mpsc::channel;

let (sender, receiver) = channel();
```

你会得到一个发送端和一个接收端。  
调用发送端的 `send` 方法可以将数据推送到通道。  
调用接收端的 `recv` 方法可以从通道中拉取数据。

### 多个发送端

`Sender` 是可克隆的：我们可以创建多个发送端（例如，为每个客户端线程创建一个），  
它们都将数据推送到同一个通道中。

而 `Receiver` 则不可克隆：一个通道只能有一个接收端。

这就是**mpsc**（多生产者单消费者）的含义！

### 消息类型

`Sender` 和 `Receiver` 都是泛型，类型参数为 `T`。  
这是通道中可以传输的**消息**的类型。

它可以是 `u64`、一个结构体、一个枚举等。

### 错误

`send` 和 `recv` 都可能失败。  
如果接收端被丢弃，`send` 会返回一个错误。  
如果所有的发送端都被丢弃且通道为空，`recv` 会返回一个错误。

换句话说，当通道被实际关闭时，`send` 和 `recv` 会报错。