## 读写锁

我们新的 `TicketStore` 可以运行，但其读取性能并不理想：一次只能有一个客户端读取特定的票据，因为 `Mutex<T>` 并不区分读取者和写入者。

我们可以通过使用一种不同的锁机制来解决这个问题：`RwLock<T>`。\
`RwLock<T>` 代表 **读写锁**。它允许 **多个读取者** 同时访问数据，但一次只允许一个写入者。

`RwLock<T>` 有两个方法用于获取锁：`read` 和 `write`。\
`read` 返回一个保护器，使您可以读取数据，而 `write` 返回一个保护器，使您可以修改数据。

```rust
use std::sync::RwLock;

// 一个用读写锁保护的整数
let lock = RwLock::new(0);

// 获取 RwLock 的读取锁
let guard1 = lock.read().unwrap();

// 在第一个读取锁仍然有效时
// 获取**第二个**读取锁
let guard2 = lock.read().unwrap();
```

## 权衡

从表面上看，`RwLock<T>` 似乎是不二之选：它提供了 `Mutex<T>` 功能的超集。\
如果可以用 `RwLock<T>`，为什么还要用 `Mutex<T>` 呢？

这里有两个关键原因：

- 锁住一个 `RwLock<T>` 比锁住一个 `Mutex<T>` 更昂贵。\
  这是因为 `RwLock<T>` 需要跟踪正在活动的读取者和写入者的数量，而 `Mutex<T>` 只需要跟踪锁是否被持有。\
  如果读取者的数量远多于写入者，这种性能开销问题不大，但在写入操作频繁的负载下，`Mutex<T>` 可能是更好的选择。
- `RwLock<T>` 可能导致 **写入者饥饿**。\
  如果总是有读取者等待获取锁，写入者可能永远没有机会运行。\
  `RwLock<T>` 不对读取者和写入者获得锁的顺序提供任何保障。\
  这取决于底层操作系统实现的策略，而该策略可能对写入者并不公平。

在我们的场景中，可以预见读取操作更频繁（因为大多数客户端是读取票据，而不是修改它们），因此 `RwLock<T>` 是一个不错的选择。