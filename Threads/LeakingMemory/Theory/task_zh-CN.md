## 数据泄漏

在传递引用给新线程时，主要关心的是“使用已释放内存”的问题：\
通过指针访问已经被释放或已被重新分配的内存区域的数据。\
如果您正在处理堆分配的数据，可以通过告知 Rust 永远不会回收该内存来避免这种问题：\
您选择**有意泄漏内存**。

这可以通过使用 Rust 标准库中的 `Box::leak` 方法来实现，例如：

```rust
// 通过将一个 `u32` 包装在 `Box` 中，在堆上分配内存。
let x = Box::new(41u32);
// 使用 `Box::leak` 告诉 Rust 您永远不会释放这块堆内存
// 这样您可以获取一个 'static 的引用。
let static_ref: &'static mut u32 = Box::leak(x);
```

## 数据泄漏的范围是进程级别的

数据泄漏是危险的：如果您不断泄漏内存，最终会导致内存耗尽并崩溃。

```rust
// 如果让这个程序运行一段时间，
// 它最终会耗尽所有可用内存。
fn oom_trigger() {
    loop {
        let v: Vec<usize> = Vec::with_capacity(1024);
        v.leak();
    }
}
```

同时，通过 `leak` 方法泄漏的内存并未真正被遗忘。\
操作系统可以将每个内存区域映射到负责它的进程。\
当进程退出时，操作系统会回收这些内存。

考虑到这一点，当以下情况时泄漏内存可能是可以接受的：

- 需要泄漏的内存量是有界的/预先已知的，或者
- 进程的生命周期很短，您确信在进程结束前不会耗尽所有可用内存

如果您的使用场景允许，“让操作系统处理”可以是一个完全合理的内存管理策略。