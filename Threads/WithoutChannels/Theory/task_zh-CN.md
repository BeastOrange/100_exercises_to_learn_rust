## 设计审查

让我们花点时间回顾一下我们所经历的旅程。

## 使用通道序列化实现无锁

我们第一个实现多线程票务存储的解决方案是：

- 使用一个长生命周期的线程（服务器）来维护共享状态  
- 多个客户端通过它们各自线程的通道向该服务器发送请求。  

不需要对状态进行锁定，因为服务器是唯一修改状态的实体。这是因为“收件箱”通道能够自然地**序列化**传入的请求：服务器会一个接一个地处理这些请求。\
我们已经讨论过在修复行为上的这一方法的局限性，但我们还未讨论原始设计在性能上的影响：服务器只能一次处理一个请求，包括读取操作。

## 细粒度锁定

然后我们转向了一个更复杂的设计，其中每张票都由其各自的锁保护，客户端可以自行决定是读取还是原子性地修改票，并获取相应的锁。

这种设计允许更好的并行性能（即多个客户端可以同时读取票务信息），但本质上它仍然是**串行**的：服务器会一个一个地处理指令。特别是，它会逐一向客户端授予锁。

我们能否完全移除通道，让客户端直接访问`TicketStore`，仅依赖锁来同步访问？

## 移除通道

我们需要解决两个问题：

- 在线程之间共享`TicketStore`
- 同步对存储的访问

### 在线程之间共享`TicketStore`

我们希望所有线程都引用同一个状态，否则我们并没有真正实现一个多线程系统——我们只是并行运行了多个单线程系统。\
在尝试跨线程共享一个锁时，我们已经遇到过这个问题：我们可以使用`Arc`。

### 同步对存储的访问

由于通道提供的序列化功能，在某些交互中依然可以实现无锁化：例如向存储中插入（或移除）一张票。\
如果我们移除了通道，就需要引入（另一个）锁来同步对`TicketStore`本身的访问。

如果我们使用`Mutex`，那么使用额外的`RwLock`对每张票加锁就没有意义了：`Mutex`已经会对整个存储的访问进行序列化，因此我们依然无法实现并行读取票。\
而如果我们使用`RwLock`，则可以实现票的并行读取。我们只需在插入或移除一张票时暂停所有读取操作。

让我们沿着这条路径看看最终会走向哪里。