## 有界与无界通道

到目前为止，我们一直在使用无界通道。\
您可以发送任意数量的消息，通道会扩展以容纳它们。\
在多生产者单消费者的场景中，这可能会引发问题：如果生产者以比消费者能处理消息更快的速度入队消息，通道会不断增长，可能会消耗掉所有可用内存。

我们的建议是，**绝不要**在生产系统中使用无界通道。\
您应始终通过使用**有界通道**来强制限制可以入队的消息数量。

## 有界通道

有界通道具有固定的容量。\
您可以通过调用 `sync_channel` 并设置一个大于零的容量来创建：

```rust
use std::sync::mpsc::sync_channel;

let (sender, receiver) = sync_channel(10);
```

`receiver` 拥有与之前相同的类型，即 `Receiver<T>`。\
而 `sender` 则是一个 `SyncSender<T>` 的实例。

### 发送消息

对于 `SyncSender`，您可以通过两种不同的方法发送消息：

- `send`：如果通道中有空间，它会将消息入队并返回 `Ok(())`。\
  如果通道已满，它将阻塞并等待，直到有可用空间。
- `try_send`：如果通道中有空间，它会将消息入队并返回 `Ok(())`。\
  如果通道已满，它将返回 `Err(TrySendError::Full(value))`，其中 `value` 是无法发送的消息。

根据您的使用场景，可能需要选择其中一种方法。

### 背压机制

使用有界通道的主要优势在于，它们提供了一种**背压**机制。\
它们迫使生产者减缓速度，以防消费者无法跟上处理速度。\
这种背压机制可以传播至整个系统，从而可能影响系统整体架构，并防止终端用户用请求压垮系统。