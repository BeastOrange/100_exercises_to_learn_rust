## 内部可变性

我们来分析一下 `Sender` 的 `send` 方法的签名：

```rust
impl<T> Sender<T> {
    pub fn send(&self, t: T) -> Result<(), SendError<T>> {
        // [...]
    }
}
```

`send` 方法接受 `&self` 作为参数。\
但它显然引发了一个变更：将新消息添加到了频道中。更加有趣的是，`Sender` 是可克隆的：我们可以有多个 `Sender` 实例\
同时尝试**从不同线程修改频道的状态**。

这是我们用来构建这种客户端-服务器架构的关键特性。但为什么它可以工作？\
这不是违反了 Rust 关于借用的规则吗？我们如何通过一个**不可变引用**进行变更操作？

## 共享引用而非真正不可变引用

在介绍借用检查器时，我们提到了 Rust 中可以使用的两种引用类型：

- 不可变引用 (`&T`)
- 可变引用 (`&mut T`)

如果更准确一点的话，我们应该称它们为：

- 共享引用 (`&T`)
- 独占引用 (`&mut T`)

不可变/可变模型适用于绝大多数情况，是学习 Rust 的一个很好的开始。\
但它并不是整个故事，因为正如你刚刚看到的，`&T` 并不真正保证它指向的数据是不可变的。\
不过不要担心，Rust 依然保持着它的承诺。\
只是这些术语比乍一看更为微妙。

## `UnsafeCell`

当某种类型允许你通过共享引用修改数据时，你正在处理 **内部可变性**。

默认情况下，Rust 编译器假设共享引用是不可变的。它基于这一假设**优化你的代码**。\
编译器可以重新排列操作、缓存值，并做各种“魔术”以让你的代码更高效。

你可以通过将数据包裹在 `UnsafeCell` 中告诉编译器“这个共享引用实际上是可变的”。\
每次遇到一个允许内部可变性的类型，你可以确定其中直接或间接地使用了 `UnsafeCell`。\
通过使用 `UnsafeCell`、原始指针和 `unsafe` 代码，你可以通过共享引用修改数据。

不过我们要明确一点：`UnsafeCell` 不是一个可以忽略借用检查器的魔法棒！\
`unsafe` 代码仍然需要遵守 Rust 关于借用和别名的规则。\
它是一个（高级的）工具，可以用来构建**安全的抽象**，这些抽象的安全性无法直接用 Rust 的类型系统表达。\
每当你使用 `unsafe` 关键字时，你实际上是在告诉编译器：\
“我知道自己在做什么，我不会破坏你的规则，请信任我。”

每次调用 `unsafe` 函数时，都会有文档说明其**安全前提条件**：在什么情况下调用其 `unsafe` 块是安全的。\
可以在 [`std` 的文档](https://doc.rust-lang.org/std/cell/struct.UnsafeCell.html)中找到 `UnsafeCell` 的相关内容。

我们在本课程中不会直接使用 `UnsafeCell`，也不会编写 `unsafe` 代码。\
但了解它的存在、它为何存在以及它如何与我们日常使用的 Rust 类型相关联是很重要的。

## 关键示例

我们来看几个使用内部可变性的重要 `std` 类型。\
这些类型在 Rust 代码中相当常见，特别是当你窥探一些库的内部时会更加熟悉。

### 引用计数

`Rc` 是一个引用计数指针。\
它包装了一个值，并跟踪对该值的引用数量。\
当最后一个引用被丢弃时，该值会被释放。\
包裹在 `Rc` 中的值是不可变的：你只能获得对它的共享引用。

```rust
use std::rc::Rc;

let a: Rc<String> = Rc::new("My string".to_string());
// 只有一个对字符串数据的引用存在。
assert_eq!(Rc::strong_count(&a), 1);

// 调用 `clone` 时，字符串数据并没有被复制！
// 相反，`Rc` 的引用计数增加了。
let b = Rc::clone(&a);
assert_eq!(Rc::strong_count(&a), 2);
assert_eq!(Rc::strong_count(&b), 2);
// ^ `a` 和 `b` 都指向相同的字符串数据，
//   并共享相同的引用计数。
```

`Rc` 内部使用 `UnsafeCell`，以便共享引用可以增加和减少引用计数。

### `RefCell`

`RefCell` 是 Rust 中内部可变性最常见的一个例子。\
即使只有对 `RefCell` 的不可变引用，`RefCell` 仍允许你修改其包含的值。

这是通过**运行时借用检查**实现的。\
`RefCell` 在运行时跟踪对其包含值的引用数量（以及引用的类型）。\
如果在已经有不可变借用的情况下尝试可变借用，该程序会触发 panic，从而确保 Rust 的借用规则始终得以执行。

```rust
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow(); // 不可变借用
let z = x.borrow_mut(); // 触发 panic！当前存在活跃的不可变借用。