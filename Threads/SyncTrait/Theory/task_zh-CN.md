## `Sync`

在结束本章之前，让我们讨论一下 Rust 标准库中的另一个关键特性：`Sync`。

`Sync` 是一个自动特性，和 `Send` 一样。\
它会自动为所有可以安全**共享**在线程之间的类型实现。

换句话说：如果 `&T` 是 `Send` 的，那么 `T` 就是 `Sync` 的。

## `T: Sync` 不代表 `T: Send`

需要注意的是，`T` 可以是 `Sync` 的，但并不一定是 `Send` 的。\
例如：`MutexGuard` 不是 `Send`，但它是 `Sync`。

它不是 `Send`，因为锁必须在获取它的同一个线程上释放，因此我们不希望 `MutexGuard` 在不同的线程上被销毁。\
但它是 `Sync` 的，因为将一个 `&MutexGuard` 提供给另一线程并不会影响锁要在哪个线程上被释放。

## `T: Send` 不代表 `T: Sync`

反之亦然：`T` 可以是 `Send` 的，但并不一定是 `Sync` 的。\
例如：`RefCell<T>` 是 `Send` 的（如果 `T` 是 `Send` 的），但它不是 `Sync` 的。

`RefCell<T>` 执行运行时借用检查，但它用来跟踪借用的计数器不是线程安全的。\
因此，如果多个线程持有同一个 `&RefCell`，可能会导致数据竞争，并可能让多个线程获得对同一数据的可变引用。因此，`RefCell` 不是 `Sync` 的。\
另一方面，`Send` 是可以的，因为当我们将一个 `RefCell` 发送到另一个线程时，我们并没有留下对其包含的数据的任何引用，因此不存在并发可变访问的风险。